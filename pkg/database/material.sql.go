// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: material.sql

package material_db

import (
	"context"
	"database/sql"
)

const getAllMaterials = `-- name: GetAllMaterials :many
SELECT id, name, type, quantity, unit, status, location_lat, location_lng, job_site, last_checked_out FROM Materials
`

type GetAllMaterialsRow struct {
	ID             int64
	Name           sql.NullString
	Type           sql.NullString
	Quantity       int64
	Unit           string
	Status         string
	LocationLat    sql.NullFloat64
	LocationLng    sql.NullFloat64
	JobSite        sql.NullInt64
	LastCheckedOut interface{}
}

func (q *Queries) GetAllMaterials(ctx context.Context) ([]GetAllMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMaterialsRow
	for rows.Next() {
		var i GetAllMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Quantity,
			&i.Unit,
			&i.Status,
			&i.LocationLat,
			&i.LocationLng,
			&i.JobSite,
			&i.LastCheckedOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialsBySite = `-- name: GetMaterialsBySite :many
SELECT id, name, type, quantity, unit, status, location_lat, location_lng, job_site, last_checked_out FROM Materials WHERE job_site=?
`

type GetMaterialsBySiteRow struct {
	ID             int64
	Name           sql.NullString
	Type           sql.NullString
	Quantity       int64
	Unit           string
	Status         string
	LocationLat    sql.NullFloat64
	LocationLng    sql.NullFloat64
	JobSite        sql.NullInt64
	LastCheckedOut interface{}
}

func (q *Queries) GetMaterialsBySite(ctx context.Context, jobSite sql.NullInt64) ([]GetMaterialsBySiteRow, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialsBySite, jobSite)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMaterialsBySiteRow
	for rows.Next() {
		var i GetMaterialsBySiteRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Quantity,
			&i.Unit,
			&i.Status,
			&i.LocationLat,
			&i.LocationLng,
			&i.JobSite,
			&i.LastCheckedOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialsByType = `-- name: GetMaterialsByType :many
SELECT id, name, type, quantity, unit, status, location_lat, location_lng, job_site , last_checked_out FROM Materials WHERE type=?
`

type GetMaterialsByTypeRow struct {
	ID             int64
	Name           sql.NullString
	Type           sql.NullString
	Quantity       int64
	Unit           string
	Status         string
	LocationLat    sql.NullFloat64
	LocationLng    sql.NullFloat64
	JobSite        sql.NullInt64
	LastCheckedOut interface{}
}

func (q *Queries) GetMaterialsByType(ctx context.Context, type_ sql.NullString) ([]GetMaterialsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMaterialsByTypeRow
	for rows.Next() {
		var i GetMaterialsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Quantity,
			&i.Unit,
			&i.Status,
			&i.LocationLat,
			&i.LocationLng,
			&i.JobSite,
			&i.LastCheckedOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
